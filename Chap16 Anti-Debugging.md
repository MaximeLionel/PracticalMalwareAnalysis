* there're hundreds of anti-debugging techniques.

# Windows Debugger Detection
* debugger detection is the most common way that malware performs anti-debugging.
## Using the Windows API
* IsDebuggerPresent
  * IsDebuggerPresent searches PEB struct for the field **IsDebugged**.
  * return nonzero if a debugger is attached.
* CheckRemoteDebuggerPresent
  * CheckRemoteDebuggerPresent searches PEB struct for the field **IsDebugged** for current process or another process by passing process handle.
* NtQueryInformationProcess
  * NtQueryInformationProcess is a native API function in Ntdll.dll that receive information about a given process.
  ```
    __kernel_entry NTSTATUS NtQueryInformationProcess(
    [in]            HANDLE           ProcessHandle,
    [in]            PROCESSINFOCLASS ProcessInformationClass,   // ProcessDebugPort (0x7)
    [out]           PVOID            ProcessInformation,
    [in]            ULONG            ProcessInformationLength,
    [out, optional] PULONG           ReturnLength
    );
  ```
  * if debugged, a port number will be returned.
* OutputDebugString
  * OutputDebugString is used to send a string to a debugger for display.
  * sample:
  ```
    DWORD errorValue = 12345;
    SetLastError(errorValue);
    OutputDebugString("Test for Debugger");
    if(GetLastError() == errorValue)
    {
    ExitProcess();      // there's a debugger attached.
    }
    else
    {
    RunMaliciousPayload();
    }
  ```
    * first use SetLastError to set last error as an arbitrary value (errorValue).
    * if there's a debugger, GetLastError will return errorValue.
## Manually Checking Structures
* manually checking structures is the most common method used by malware authors.
### Checking BeingDebugged Flag
* PEB structure is maintained by OS **for each process**, which contains all user-mode parameters associated with a process.
* example of documented PEB struct:
```
    typedef struct _PEB {
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[1];
    PVOID Reserved3[2];
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    BYTE Reserved4[104];                            // undocumented: ProcessHeap
    PVOID Reserved5[52];
    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
    BYTE Reserved6[128];
    PVOID Reserved7[1];
    ULONG SessionId;
    } PEB, *PPEB;
```
* when a process is running, PEB can be referenced by fs:[30h].
* BeingDebugged Flag check method (mov):
```
    mov eax, dword ptr fs:[30h]
    mov ebx, byte ptr [eax+2]
    test ebx, ebx
    jz NoDebuggerDetected
```
* BeingDebugged Flag check method (push):
```
    push dword ptr fs:[30h]
    pop edx
    cmp byte ptr [edx+2], 1
    je DebuggerDetected
```
* how to solve?
  * force the jump to be taken.
  * manually change **BeingDebugged** flag to 0.
### Checking ProcessHeap Flag
* ProcessHeap of PEB points to the location of a process's first heap allocated by the loader.
* ForceFlags and Flags: the first heap contains a header with fields to tell the kernel whether the heap was created within a debugger.
* ForceFlags: 0x10 on xp, 0x44 on win7.
* Flags: 0xC on xp, 0x40 on win7.
* example of checking code:
```
    mov eax, large fs:30h
    mov eax, dword ptr [eax+18h]
    cmp dword ptr ds:[eax+10h], 0
    jne DebuggerDetected
```
* how to solve?
  * change ProcessHeap flag manually.
  * use a hide-debug plug-in on debugger.
    * command on windbg: windbg -hd notepad.exe.
### Checking NTGlobalFlag
* When a process is created with a debugger, it creates memory heaps differently.
* value of PEB offset 0x68 = 0x70 if a heap is created by a debugger.
  ```
    0x70 = (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)
  ```
* NTGlobalFlag check code:
  ```
    mov eax, large fs:30h
    cmp dword ptr ds:[eax+68h], 70h
    jz DebuggerDetected
  ```
* how to solve?
  * change NTGlobalFlag manually.
  * use hide-debug plug-in for debugger.
## Check for System Residue
* when analyzing malware, we typically use debugging tools, which **leave residue** on the system.
* registry keys for reference to debuggers:
  ```
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug
  ```
  * this key specifies the debugger that activates when an application error occurs. By default, it's set to Dr. Watson.
* malware also searches the system for files and directories for common debugger program executables.
* malware can detect residue in live memory by viewing current process listing. Or by performing a FindWindow in searching for a debugger.
  ```
    if(FindWindow("OLLYDBG", 0) == NULL)
    {
    //Debugger Not Found
    }
    else
    {
    //Debugger Detected
    }
  ```

# Identifying Debugger Behavior
* several anti-debugging techniques are used by malware to detect debugger behaviors: INT scanning, checksum checks, and timing checks.
## INT Scanning
* INT 3 (0xCC) is the **software interrupt** used by debuggers to temporarily **replace an instruction** in a running program and to call the **debug exception handler** - a basic mechanism to set breakpoint.
* INT immediate: 0xCD 0xCD can also set breakpoint.
* one common anti-debugging technique - search 0xcc:
  ```
    call $+5                // push eip, jmp $+5
    pop edi                 // edi = eip
    sub edi, 5              // set search starting point
    mov ecx, 400h
    mov eax, 0CCh
    repne scasb             // search 0xCC in current code area
    jz DebuggerDetected
  ```
## Performing Code Checksums
* malware can calculate a checksum on a section of code to simply perform a cyclic redundancy check or a MD5 checksum of the opcodes in the malware.
* how to solve?
  * using hardware breakpoints.
  * manually modifying execution path with the debugger at runtime.
## Timing Checks
* timing checks are one of the most popular ways for malware to detect debuggers because processes run more slowly when being debugged.
* the ways for timing checks to detect a debugger:
  * record a timestamp, perform operations, take another timestamp, and then compare 2 timestamp.
  * take timestamps before and after an exception.
### Using the rdtsc Instruction
* the most common timing check method is the rdtsc instruction (opcode 0x0F31), which returns the count of ticks since last reboot as a 64bit value placed into EDX:EAX.
  * malware will simply execute rdtsc twice and compare the difference between 2 readings.
* sample of rdtsc:
  ```
    rdtsc
    xor ecx, ecx
    add ecx, eax        // ecx = 1st record
    rdtsc
    sub eax, ecx        // eax = 2nd record - 1st record
    cmp eax, 0xFFF 
    jb NoDebuggerDetected
    rdtsc
    push eax 
    ret
  ```
### Using QueryPerformanceCounter and GetTickCount
* example of GetTickCount:
  ```
    a = GetTickCount();
    MaliciousActivityFunction();
    b = GetTickCount();
    delta = b-a;
    if ((delta) > 0x1A)
    {
    //Debugger Detected
    } 
    else 
    {
    //Debugger Not Found
    }
  ```

  # Interfering with Debugger Functionality
  * malware can use several techniques to interfere with normal debugger operation: thread local storage (TLS) callbacks, exceptions, and interrupt insertion.