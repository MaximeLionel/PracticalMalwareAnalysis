* there're hundreds of anti-debugging techniques.

# Windows Debugger Detection
* debugger detection is the most common way that malware performs anti-debugging.
## Using the Windows API
* IsDebuggerPresent
  * IsDebuggerPresent searches PEB struct for the field **IsDebugged**.
  * return nonzero if a debugger is attached.
* CheckRemoteDebuggerPresent
  * CheckRemoteDebuggerPresent searches PEB struct for the field **IsDebugged** for current process or another process by passing process handle.
* NtQueryInformationProcess
  * NtQueryInformationProcess is a native API function in Ntdll.dll that receive information about a given process.
  ```
    __kernel_entry NTSTATUS NtQueryInformationProcess(
    [in]            HANDLE           ProcessHandle,
    [in]            PROCESSINFOCLASS ProcessInformationClass,   // ProcessDebugPort (0x7)
    [out]           PVOID            ProcessInformation,
    [in]            ULONG            ProcessInformationLength,
    [out, optional] PULONG           ReturnLength
    );
  ```
  * if debugged, a port number will be returned.
* OutputDebugString
  * OutputDebugString is used to send a string to a debugger for display.
  * sample:
  ```
    DWORD errorValue = 12345;
    SetLastError(errorValue);
    OutputDebugString("Test for Debugger");
    if(GetLastError() == errorValue)
    {
    ExitProcess();      // there's a debugger attached.
    }
    else
    {
    RunMaliciousPayload();
    }
  ```
    * first use SetLastError to set last error as an arbitrary value (errorValue).
    * if there's a debugger, GetLastError will return errorValue.
## Manually Checking Structures
* manually checking structures is the most common method used by malware authors.
### Checking BeingDebugged Flag
* PEB structure is maintained by OS **for each process**, which contains all user-mode parameters associated with a process.
* example of documented PEB struct:
```
    typedef struct _PEB {
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[1];
    PVOID Reserved3[2];
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    BYTE Reserved4[104];                            // undocumented: ProcessHeap
    PVOID Reserved5[52];
    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
    BYTE Reserved6[128];
    PVOID Reserved7[1];
    ULONG SessionId;
    } PEB, *PPEB;
```
* when a process is running, PEB can be referenced by **fs:[30h]**.
* BeingDebugged Flag check method (mov):
```
    mov eax, dword ptr fs:[30h]
    mov ebx, byte ptr [eax+2]
    test ebx, ebx
    jz NoDebuggerDetected
```
* BeingDebugged Flag check method (push):
```
    push dword ptr fs:[30h]
    pop edx
    cmp byte ptr [edx+2], 1
    je DebuggerDetected
```
* how to solve?
  * force the jump to be taken.
  * manually change **BeingDebugged** flag to 0.
### Checking ProcessHeap Flag
* ProcessHeap of PEB points to the location of a process's first heap allocated by the loader.
* ForceFlags and Flags: the first heap contains a header with fields to tell the kernel whether the heap was created within a debugger.
* ForceFlags: 0x10 on xp, 0x44 on win7.
* Flags: 0xC on xp, 0x40 on win7.
* example of checking code:
```
    mov eax, large fs:30h
    mov eax, dword ptr [eax+18h]
    cmp dword ptr ds:[eax+10h], 0
    jne DebuggerDetected
```
* how to solve?
  * change ProcessHeap flag manually.
  * use a hide-debug plug-in on debugger.
    * command on windbg: windbg -hd notepad.exe.
### Checking NTGlobalFlag
* When a process is created with a debugger, it creates memory heaps differently.
* value of PEB offset 0x68 = 0x70 if a heap is created by a debugger.
  ```
    0x70 = (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)
  ```
* NTGlobalFlag check code:
  ```
    mov eax, large fs:30h
    cmp dword ptr ds:[eax+68h], 70h
    jz DebuggerDetected
  ```
* how to solve?
  * change NTGlobalFlag manually.
  * use hide-debug plug-in for debugger.
## Check for System Residue
* when analyzing malware, we typically use debugging tools, which **leave residue** on the system.
* registry keys for reference to debuggers:
  ```
    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug
  ```
  * this key specifies the debugger that activates when an application error occurs. By default, it's set to Dr. Watson.
* malware also searches the system for files and directories for common debugger program executables.
* malware can detect residue in live memory by viewing current process listing. Or by performing a FindWindow in searching for a debugger.
  ```
    if(FindWindow("OLLYDBG", 0) == NULL)
    {
    //Debugger Not Found
    }
    else
    {
    //Debugger Detected
    }
  ```

# Identifying Debugger Behavior
* several anti-debugging techniques are used by malware to detect debugger behaviors: INT scanning, checksum checks, and timing checks.
## INT Scanning
* INT 3 (0xCC) is the **software interrupt** used by debuggers to temporarily **replace an instruction** in a running program and to call the **debug exception handler** - a basic mechanism to set breakpoint.
* INT immediate: 0xCD 0xCD can also set breakpoint.
* one common anti-debugging technique - search 0xcc:
  ```
    call $+5                // push eip, jmp $+5
    pop edi                 // edi = eip
    sub edi, 5              // set search starting point
    mov ecx, 400h
    mov eax, 0CCh
    repne scasb             // search 0xCC in current code area
    jz DebuggerDetected
  ```
## Performing Code Checksums
* malware can calculate a checksum on a section of code to simply perform a cyclic redundancy check or a MD5 checksum of the opcodes in the malware.
* how to solve?
  * using hardware breakpoints.
  * manually modifying execution path with the debugger at runtime.
## Timing Checks
* timing checks are one of the most popular ways for malware to detect debuggers because processes run more slowly when being debugged.
* the ways for timing checks to detect a debugger:
  * record a timestamp, perform operations, take another timestamp, and then compare 2 timestamp.
  * take timestamps before and after an exception.
### Using the rdtsc Instruction
* the most common timing check method is the rdtsc instruction (opcode 0x0F31), which returns the count of ticks since last reboot as a 64bit value placed into EDX:EAX.
  * malware will simply execute rdtsc twice and compare the difference between 2 readings.
* sample of rdtsc:
  ```
    rdtsc
    xor ecx, ecx
    add ecx, eax        // ecx = 1st record
    rdtsc
    sub eax, ecx        // eax = 2nd record - 1st record
    cmp eax, 0xFFF 
    jb NoDebuggerDetected
    rdtsc
    push eax 
    ret
  ```
### Using QueryPerformanceCounter and GetTickCount
* example of GetTickCount:
  ```
    a = GetTickCount();
    MaliciousActivityFunction();
    b = GetTickCount();
    delta = b-a;
    if ((delta) > 0x1A)
    {
    //Debugger Detected
    } 
    else 
    {
    //Debugger Not Found
    }
  ```

# Interfering with Debugger Functionality
* malware can use several techniques to interfere with normal debugger operation: thread local storage (TLS) callbacks, exceptions, and interrupt insertion.
## Using TLS Callbacks
* when load a program,  most debuggers will pause at the program's entry point. But TLS can execute code secretly before entry point.
* TLS is a Windows storage class in which a data object is **local to each thread** that runs the code.
* TLS allows **each thread** to maintain a **different** value for a variable declared using TLS.
* when TLS is implemented by an exe, the code will typically **maintain a .tls section** in PE header.
* TLS supports callback functions for **initialization and termination of TLS data objects**. TLS execute these functions before running code at normal start of the program.
* PE view can view **.tls section** which includes TLS callback functions.
* how to solve?
  * OllyDbg: Options->Debugging Options->Events and setting System breakpoint.
* TLS method is well-known, so fewer malware use TLS.
## Using Exceptions
* interrupts generate exceptions that are used by debugger to perform operations like breakpoints.
* how to detect debuggers by exceptions:
  * the default setting on most debuggers is to trap exceptions and not pass them to handling program.
  * if debugger doesn't pass exception to the process properly, the failure can be detected within process exception-handling mechanism.
  * for OllyDbg default settings, all exceptions will be trapped unless it's tickled below:
  ![ODExceptionSettings](./Figure16_4.JPG)
* when doing malware analysis, suggesting to tickled all the boxes above.
## Inserting Interrupts
* a classic form of anti-debugging is to disrupt normal execution by inserting interrupts in the middle of instruction sequence.
### Inserting INT3
* one anti-debugging technique is to insert 0xCC in order to trick the debugger.
* 0xCD03 can also generate an INT3. This can interfere with Windbg.
  * Windbg can catch the breakpoint and advance EIP by only one byte which can cause a totally different set of instructions.
  * OllyDbg cannot be attacked by 0xCD03.
* example:
  ```
    push offset continue
    push dword fs:[0] 
    mov fs:[0], esp         // construct a new SEH (continue) on stack
    int 3                   // if program not being debugged, it will go to SEH which is on top of stack (continue).
    //being debugged
    continue: 
    //not being debugged
  ```
### Inserting INT2D
* INT2D is the way that kernel debuggers set breakpoints.
### Inserting ICE
* ICE: in circuit emulator (0xF1).

# Debugger Vulnerabilities
* sometimes malware authors attack debugger vulnerabilities to prevent debugging.
## PE Header Vulnerabilities
* modify PE header of a binary executable to cause OllyDbg to crash when loading PE.
* 1st method - for IMAGE_OPTIONAL_HEADER->NumberOfRvaAndSizes:
  * usually the value is 0x10 which is the number of entries in DataDirectory array.
  * when we modify it to 0x99, windows loader will ignore this. However OllyDbg will not, thus lead to crash.
* 2nd method - for IMAGE_SECTION_HEADER->SizeOfRawData:
  * Windows Loader usually use the smaller one of VirtualSize and SizeOfRawData to map the section into memory.
  * if we modify SizeOfRawData to an extreamly large number, since OllyDbg only uses SizeOfRawData, it will cause OllyDbg to crash.
  * how to solve? - change SizeOfRawData into a value close to VirtualSize. Or use PE Explorer tool.
## The OutputDebugString Vulnerability
* OutputDebugString("%s%s%s%s%s%s%s%s%s%s%s%s%s%s") will cause OllyDbg1.1 to crash.
