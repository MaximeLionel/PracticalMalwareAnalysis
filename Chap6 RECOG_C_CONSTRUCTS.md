* Code Construct: a code abstraction level that defines a functional property but not the details of its implementation.
* constructs are different betweem compilers.
* most malware is written in C.
* goal is to understand the overall functionality of a program, not to analyze every single instruction.

# Global vs Local Variables
* global variables are referenced by memory addresses.
* local variables are referenced by stack addresses (bp - offset).

# Disassembly Arithmetic Operations

# Recoginizing if Statements
## Analyzing Functions Graphically with IDA Pro
## Recoginizing Nested if Statements

# Recognizing Loops
## Finding for Loops
## Finding while loops

# Understanding Function Call Conventions
## cdecl
* parameters are pushed onto stack from right to left.
* the **caller** cleans up the stack when function is complete.
* return value is stored in eax.
## stdcall
* parameters are pushed onto stack from right to left.
* the **callee** cleans up the stack when function is complete.
* return value is stored in eax.
## fastcall
* the first 2 parameters are passed by registers (ecx and edx in order) from left to right. Other parameters are passed on the stack from right to left.
* the **callee** cleans up the stack when function is complete.
## Push vs Move

# Analyzing switch Statements
* backdoors commonly select from a series of actions using a single byte value through 'switch'.
* 'switch' statements are compiled in 2 common ways: using **if** style or using **jump** tables.
## if Style
```
    switch(i)
    {
    case 1:
    printf("i = %d", i+1);
    break;
    case 2:
    printf("i = %d", i+2);
    break;
    case 3:
    printf("i = %d", i+3);
    break;
    default:
    break;
    }
```
```
    00401013 cmp [ebp+var_8], 1
    00401017 jz short loc_401027 
    00401019 cmp [ebp+var_8], 2
    0040101D jz short loc_40103D
    0040101F cmp [ebp+var_8], 3
    00401023 jz short loc_401053
    00401025 jmp short loc_401067 
    00401027 loc_401027:
    00401027 mov ecx, [ebp+var_4] 
    0040102A add ecx, 1
    0040102D push ecx
    0040102E push offset unk_40C000 ; i = %d
    00401033 call printf
    00401038 add esp, 8
    0040103B jmp short loc_401067
    0040103D loc_40103D:
    0040103D mov edx, [ebp+var_4] 
    00401040 add edx, 2
    00401043 push edx
    00401044 push offset unk_40C004 ; i = %d
    00401049 call printf
    0040104E add esp, 8
    00401051 jmp short loc_401067
    Recognizing C Code Constructs in Assembly 123
    00401053 loc_401053:
    00401053 mov eax, [ebp+var_4] 
    00401056 add eax, 3
    00401059 push eax
    0040105A push offset unk_40C008 ; i = %d
    0040105F call printf
    00401064 add esp, 8
```
## Jump Table
```
    switch(i)
    {
    case 1:
    printf("i = %d", i+1);
    break;
    case 2:
    printf("i = %d", i+2);
    break;
    case 3:
    printf("i = %d", i+3);
    break;
    default:
    break;
    }
```
```
    00401016 sub ecx, 1
    00401019 mov [ebp+var_8], ecx
    0040101C cmp [ebp+var_8], 3
    00401020 ja short loc_401082
    00401022 mov edx, [ebp+var_8]
    00401025 jmp ds:off_401088[edx*4] 
    0040102C loc_40102C:
    ...
    00401040 jmp short loc_401082
    00401042 loc_401042:
    ...
    00401056 jmp short loc_401082
    00401058 loc_401058:
    ...
    0040106C jmp short loc_401082
    0040106E loc_40106E:
    ...
    00401082 loc_401082: 
    00401082 xor eax, eax
    00401084 mov esp, ebp
    00401086 pop ebp
    00401087 retn
    00401087 _main endp
    00401088 off_401088 dd offset loc_40102C    // Jump Table
    0040108C dd offset loc_401042   
    00401090 dd offset loc_401058
    00401094 dd offset loc_40106E
```

# Disassembly Arrays
* malware sometimes uses an array of pointers to strings that contain **multiple hostnames** as options for **connections**.
```
    int b[5] = {123,87,487,7,978};
    void main()
    {
    int i;
    int a[5];
    for(i = 0; i<5; i++)
    { 
    a[i] = i;
    b[i] = i;
    }
    }
```
```
    00401006 mov [ebp+var_18], 0            // i = 0
    0040100D jmp short loc_401018
    0040100F loc_40100F:
    0040100F mov eax, [ebp+var_18]
    00401012 add eax, 1
    00401015 mov [ebp+var_18], eax
    00401018 loc_401018:
    00401018 cmp [ebp+var_18], 5
    0040101C jge short loc_401037           // if i >=5, end the loop.
    0040101E mov ecx, [ebp+var_18]
    00401021 mov edx, [ebp+var_18]
    00401024 mov [ebp+ecx*4+var_14], edx    // var_14 = a[0], a[i] = i.
    00401028 mov eax, [ebp+var_18]
    0040102B mov ecx, [ebp+var_18]
    0040102E mov dword_40A000[ecx*4], eax   // dword_40A000 = b[0], b[i] = i.
    00401035 jmp short loc_40100F
```

# Identifying Structs
* structures are commonly used by malware to group information.
* structures are accessed with **a base address** used as a starting point.
* using **T hotkey** to create structures in IDA Pro.
```
    struct my_structure { 
    int x[5];
    char y;
    double z;
    };
    struct my_structure *gms; 
    void test(struct my_structure *q)
    {
    int i;
    q->y = 'a';
    q->z = 15.6;
    for(i = 0; i<5; i++){ 
    q->x[i] = i;
    }
    }
    void main()
    {
    gms = (struct my_structure *) malloc(
    sizeof(struct my_structure));
    test(gms);
    }
```
* main:
``` main
    00401050 push ebp 
    00401051 mov ebp, esp 
    00401053 push 20h 
    00401055 call malloc 
    0040105A add esp, 4
    0040105D mov dword_40EA30, eax 
    00401062 mov eax, dword_40EA30
    00401067 push eax 
    00401068 call sub_401000
    0040106D add esp, 4
    00401070 xor eax, eax 
    00401072 pop ebp 
    00401073 retn
```
* test:
```
    00401000 push ebp
    00401001 mov ebp, esp
    00401003 push ecx
    00401004 mov eax,[ebp+arg_0]            // eax = para (struct my_structure *gms)
    00401007 mov byte ptr [eax+14h], 61h    // eax+14h (gms->y) = 'a'
    0040100B mov ecx, [ebp+arg_0]           // ecx = para (struct my_structure *gms)
    0040100E fld ds:dbl_40B120              // loading floating point value.
                                            // push ds:dbl_40B120 onto FPU register stack.
    00401014 fstp qword ptr [ecx+18h]       // store floating point value.
                                            // copy (ST0) to qword ptr [ecx+18h] and pop register stack.
                                            // ecx+18h (gms->z) = 15.6
    00401017 mov [ebp+var_4], 0             // i = 0
    0040101E jmp short loc_401029
    00401020 loc_401020: 
    00401020 mov edx,[ebp+var_4]
    00401023 add edx, 1                     // i++
    00401026 mov [ebp+var_4], edx
    00401029 loc_401029: 
    00401029 cmp [ebp+var_4], 5
    0040102D jge short loc_40103D           // if i>=5, end of loop
    0040102F mov eax,[ebp+var_4]            // eax = i
    00401032 mov ecx,[ebp+arg_0]            // ecx = para
    00401035 mov edx,[ebp+var_4]            // edx = i
    00401038 mov [ecx+eax*4],edx            // x[i] = i
    0040103B jmp short loc_401020
    0040103D loc_40103D: 
    0040103D mov esp, ebp
    0040103F pop ebp
    00401040 retn
```

# Analyzing Linkd List Traversal
```
    struct node
    {
    int x;
    struct node * next;
    };
    typedef struct node pnode;
    void main() 
    {
    pnode * curr, * head;
    int i;
    head = NULL;
    for(i=1;i<=10;i++) 
    {
    curr = (pnode *)malloc(sizeof(pnode));
    curr->x = i;
    curr->next = head;
    head = curr;
    }
    curr = head;
    while(curr) 
    {
    printf("%d\n", curr->x);
    curr = curr->next ;
    }
    }
```
```
    0040106A mov [ebp+var_8], 0         // head = NULL
    00401071 mov [ebp+var_C], 1         // i = 1
    00401078
    00401078 loc_401078:
    00401078 cmp [ebp+var_C], 0Ah       // i (var_C)
    0040107C jg short loc_4010AB        // if i > 10, end of loop.
    0040107E mov [esp+18h+var_18], 8
    00401085 call malloc
    0040108A mov [ebp+var_4], eax       // curr (var_4) = (pnode *)malloc(sizeof(pnode))
    0040108D mov edx, [ebp+var_4]
    00401090 mov eax, [ebp+var_C]
    00401093 mov [edx], eax             // curr->x = i
    00401095 mov edx, [ebp+var_4]
    00401098 mov eax, [ebp+var_8]
    0040109B mov [edx+4], eax           // curr->next = head (var_8)
    0040109E mov eax, [ebp+var_4]
    004010A1 mov [ebp+var_8], eax       // head = curr
    004010A4 lea eax, [ebp+var_C]
    004010A7 inc dword ptr [eax]        // i++
    004010A9 jmp short loc_401078
    004010AB loc_4010AB:
    004010AB mov eax, [ebp+var_8]
    004010AE mov [ebp+var_4], eax       // curr = head
    004010B1
    004010B1 loc_4010B1:
    004010B1 cmp [ebp+var_4], 0 
    004010B5 jz short locret_4010D7     // if curr == 0, end of loop.
    004010B7 mov eax, [ebp+var_4]
    004010BA mov eax, [eax]
    004010BC mov [esp+18h+var_14], eax  // curr->x
    004010C0 mov [esp+18h+var_18], offset aD ; "%d\n"   // "%d\n"
    004010C7 call printf
    004010CC mov eax, [ebp+var_4]       
    004010CF mov eax, [eax+4]           
    004010D2 mov [ebp+var_4], eax       // curr = curr -> next
    004010D5 jmp short loc_4010B1 
```

# Lab 6-1:
1. 0x401000.
2. printf.
3. Checks for the internet connection. If there's internet connection, print 'Success: Internet Connection.'.
   If no internet connection, print 'Error 1.1: No Internet.'.

# Lab 6-2:
1. check for the internet connection.
2. printf.
3. call and download webpage located at: http://www.practicalmalwareanalysis.com/cc.html.
4. char array: buff[0x200].
5. The program uses the HTTP User-Agent Internet Explorer 7.5/pma and downloads the web page located at: http://www.practicalmalwareanalysis.com/cc.htm.
6. Check for internet connection, then download html page from http://www.practicalmalwareanalysis.com/cc.html.

# Lab 6-3:
1. int __cdecl file_manipulation(char pread_html_char, LPCSTR lpCmdInFileName).
2. char pread_html_char, LPCSTR lpCmdInFileName.
3. switch.
4. file manipulation.
5. The registry key Software\Microsoft\Windows\CurrentVersion\Run\Malware and the file location C:\Temp\cc.exe can both be host-based indicators.
6. download html document and check the 1st letter then do the actions.

# Lab 6-4:
1. main structure is different.
2. for loop.
3. the format string Internet Explorer 7.50/pma%d.
4. 24h.
5. the format string Internet Explorer 7.50/pma%d.
6. download html document and check the 1st letter then do the actions for 24 hours.    