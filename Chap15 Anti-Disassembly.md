# Understanding Anti-Disassembly
* When implementing anti-disassembly, the malware author creates a sequence that tricks the disassembler into showing a list of instructions that differ from those will be executed.
* example of a same sequence of instructions:
  * linear disassembler:
  ```
    jmp short near ptr loc_2+1
    ; ---------------------------------------------------------------------------
    loc_2: 
    call near ptr 15FF2A71h 
    or [ecx], dl
    inc eax
    ; ---------------------------------------------------------------------------
    db 0
  ```
  * flow-oriented disassembler:
  ```
    jmp short loc_3
    ; ---------------------------------------------------------------------------
    db 0E8h
    ; ---------------------------------------------------------------------------
    loc_3: 
    push 2Ah
    call Sleep
  ```

# Defeating Disassembly Algorithms
* 2 types of disassembler algorithms: linear and flow-oriented.
## Linear Disassembly
* linear disassembly iterates over a block of code, disassembling one instruction at a time linearly without deviating.
* linear disassembly uses the size of instruction to determine which byte to disassembly next, without regard for flow-control instructions.
* sample code to disassembly:
  ```
    char buffer[BUF_SIZE];
    int position = 0;
    while (position < BUF_SIZE) {
        x86_insn_t insn;
        int size = x86_disasm(buf, BUF_SIZE, 0, position, &insn);       // populate buf with instructions it just disassembled and return the size of the instruction. Also increment position by size.
        
        if (size != 0) {
            char disassembly_line[1024];
            x86_format_insn(&insn, disassembly_line, 1024, intel_syntax);
            printf("%s\n", disassembly_line);
            position += size;
        } else 
        {
            /* invalid/unrecognized instruction */
            position++;
        }
    }
    x86_cleanup();
  ```
    * this algorithm will keep **blindly disassembling** until end.
    * if the .text section contains not only code, it will also disassemble thus cause errors.
* linear disassebly is easiest to defeat because it cannot distinguish between code and data.
## Flow-Oriented Disassembly
* most commercial disassemblers use flow-oriented disassembly method, such as IDA.
* flow-oriented disassembly method examines each instruction and builds a list of locations to disassemble.
* example:
  ```
    test eax, eax
    jz short loc_1A
    push Failed_string
    call printf
    jmp short loc_1D
    ; ---------------------------------------------------------------------------
    Failed_string: db 'Failed',0
    ; ---------------------------------------------------------------------------
    loc_1A: 
    xor eax, eax
    loc_1D:
    retn
  ```
    * when disassembler meet 'jz' instruction as a conditional instruction, it will disassemble 'push' instruction, and add loc_1A to **a list of locations to disassemble in future**.
    * when disassembler meet 'jmp' instruction, it will addd loc_1D to **a list of locations to disassemble in future**. 
    * because 'jmp' is unconditional, disassembler will not disassemble the disassemble instructions after 'jmp'. Instead, disassembler will start to check **the list of locations to disassemble in future** and start to disassemble the list.
* when conditional branches give flow-oriented disassembler a choice of 2 places to disassemble: true or false. Most flow-oriented disassembler will **process false branch first**.
* when flow-oriented disassembler meet 'call' instruction, it will mostly **disassemble the instructions after call firstly**.
* special 'call' example:
  ![specialcall](./Figure15_1.JPG)
  * the purpose of the 'call' is to create a pointer to 'hello' string. Then pop the pointer and put it into eax.
  * when IDA disassemble it, it will be wrong as below:
  ```
    E8 06 00 00 00  call near ptr loc_4011CA+1
    68 65 6C 6C 6F  push 6F6C6C65h
    loc_4011CA:
    00 58 C3        add [eax-3Dh], bl
  ```
  * if IDA is wrong, can use C or D keys:
    * C turns cursor location into code.
    * D turns cursor location into data.

# Anti-Disassembly Techniques
## Jump Instructions with the Same Target
* most common anti-disassembly technique is 2 back-to-back conditional jump instructions that both point to the same target.
* example:
  ```
    74 03 jz short near ptr loc_4011C4+1
    75 01 jnz short near ptr loc_4011C4+1
    loc_4011C4: ; CODE XREF: sub_4011C0
    ; sub_4011C0+2j
    E8 58 C3 90 90 call near ptr 90D0D521h
  ```
  * when disassembler encounters jz or jnz, it continues disassembling the false branch.
  * but the loc_4011C4+1 is 1 byte beyond E8 which is 58. but disassembler will disassemble E8 as call.
  * after D fixing, it should be like this:
  ```
    74 03 jz short near ptr loc_4011C5
    75 01 jnz short near ptr loc_4011C5
    ; -------------------------------------------------------------------
    E8 db 0E8h
    ; -------------------------------------------------------------------
    loc_4011C5: ; CODE XREF: sub_ 4011C0
    ; sub_4011C0+2j
    58 pop eax
    C3 retn
  ```
  * IDA show bytes: Options->General.
## A Jump Instruction with a Constant Condition
* another anti-disassembly technique: a single conditional jump where the condition will be always same.
* example of ida disassembly:
  ```
    33 C0           xor eax, eax
    74 01           jz short near ptr loc_4011C4+1
                    loc_4011C4: ; CODE XREF: 004011C2j
                    ; DATA XREF: .rdata:004020ACo
    E9 58 C3 68 94  jmp near ptr 94A8D521h
  ```
  * because of 'xor eax, eax', 'jz' is a must execution. 
  * ida will disassemble the false branch of 'jz', thus disassemble 'E9' as jmp.
  * use D to fix 'E9':
  ```
    33 C0   xor eax, eax
    74 01   jz short near ptr loc_4011C5
    ; --------------------------------------------------------------------
    E9      db 0E9h
    ; --------------------------------------------------------------------
            loc_4011C5: ; CODE XREF: 004011C2j
            ; DATA XREF: .rdata:004020ACo
    58      pop eax
    C3      retn
  ```
## Impossible Disassembly
* rogue byte: not part of program and is only in the code of disassembler.
* No disassembler can represent **a single byte as part of 2 instructions**, but the processor has no such limitation.
* example:
  ![inwardpointingjmp](./figure15_4.JPG)
  * modern disassembler has not way to represent 'FF' as both part of 'jmp' and part of 'inc eax'.
  * the 4 bytes sequence of increment eax and decrement eax which is actually NOP sequence, which could be inserted into any location within a program.
  * to solve this technique, malware analyst could choose to replace the entire 4 bytes with NOP instructions. Or can just use D to turn the entire 4 bytes into data.
* complex example:
  ![multilevelinwardjmp](./Figure15_5.JPG)
  * disassembler will disassemble as rule. and when ecounter 'jz', disassembler will choose false branch thus to disasemble 'E8' as a call.
  * when processor execute, it will recognize 'EB 05' as 'jmp 5' directly and continue execute.
  * when disassembled by IDA:
  ```
    66 B8 EB 05     mov ax, 5EBh
    31 C0           xor eax, eax
    74 F9           jz short near ptr sub_4011C0+1
                    loc_4011C8: 
    E8 58 C3 90 90  call near ptr 98A8D525h
  ```
  * use D and C to resolve like this:
  ```
    66 byte_4011C0  db 66h
    B8              db 0B8h
    EB              db 0EBh
    05              db 5
    ; ------------------------------------------------------------
    31 C0           xor eax, eax
    ; ------------------------------------------------------------
    74              db 74h
    F9              db 0F9h 
    E8              db 0E8h
    ; ------------------------------------------------------------
    58              pop eax
    C3              retn
  ```
  * use IDAPython script to patch NOP bytes:
  ```
    def NopBytes(start, length):
        for i in range(0, length):
            PatchByte(start + i, 0x90)
        MakeCode(start)

    NopBytes(0x004011C0, 4)
    NopBytes(0x004011C6, 3)
  ```
    * the result would be like:
    ```
        90 nop
        90 nop
        90 nop
        90 nop
        31 C0 xor eax, eax
        90 nop
        90 nop
        90 nop
        58 pop eax
        C3 retn
    ```
## NOP-ing Out Instructions with IDA Pro
* establish hotkey 'alt-N' in IDA, which will NOP-out the instruction that is currently at cursor location.
  ```
    import idaapi
    idaapi.CompileLine('static n_key() { RunPythonStatement("nopIt()"); }')
    AddHotkey("Alt-N", "n_key")
    def nopIt():
    
        start = ScreenEA()
        end = NextHead(start)
        for ea in range(start, end):
        PatchByte(ea, 0x90)
        Jump(end)
        Refresh()
  ```

# Obscuring Flow Control
## The Function Pointer Problem
```
    004011C0 sub_4011C0 proc near ; DATA XREF: sub_4011D0+5o
    004011C0
    004011C0 arg_0 = dword ptr 8
    004011C0
    004011C0 push ebp
    004011C1 mov ebp, esp
    004011C3 mov eax, [ebp+arg_0]
    004011C6 shl eax, 2
    004011C9 pop ebp
    004011CA retn
    004011CA sub_4011C0 endp
    004011D0 sub_4011D0 proc near ; CODE XREF: _main+19p
    004011D0 ; sub_401040+8Bp
    004011D0
    004011D0 var_4 = dword ptr -4
    004011D0 arg_0 = dword ptr 8
    004011D0
    004011D0 push ebp
    004011D1 mov ebp, esp
    004011D3 push ecx
    004011D4 push esi
    004011D5 mov [ebp+var_4], offset sub_4011C0     // IDA will find through cross-reference of sub_4011C0
    004011DC push 2Ah
    004011DE call [ebp+var_4]                       // IDA cannot find through cross-reference of sub_4011C0
    004011E1 add esp, 4
    004011E4 mov esi, eax
    004011E6 mov eax, [ebp+arg_0]
    004011E9 push eax
    004011EA call [ebp+var_4]                       // IDA cannot find through cross-reference of sub_4011C0
    004011ED add esp, 4
    004011F0 lea eax, [esi+eax+1]
    004011F4 pop esi
    004011F5 mov esp, ebp
    004011F7 pop ebp
    004011F8 retn
    004011F8 sub_4011D0 endp
```
* when a function offset is loaded into a stack variable, IDA is able to detect the initial reference of the offset loading. But IDA cannot detect when the stack variable is called in the future.
## Adding Missing Code Cross-Reference in IDA Pro
* to solve the problem above, we can use IDC language to tell IDA the function is called from stack variables.
```
    AddCodeXref(0x004011DE, 0x004011C0, fl_CF);
    AddCodeXref(0x004011EA, 0x004011C0, fl_CF);
```
## Return Pointer Abuse
* call is a combination of **push and jmp**, while retn is a combination of **pop and jmp**.
* example:
```
004011C0 sub_4011C0 proc near ; CODE XREF: _main+19p
004011C0 ; sub_401040+8Bp
004011C0
004011C0 var_4 = byte ptr -4
004011C0
004011C0 call $+5               // push 004011C5 (esp = esp - 4), jmp 004011C5
004011C5 add [esp+4+var_4], 5   // esp+4+var_4=esp which is top of stack with value=004011C5
                                // add [esp+4+var_4], 5 = stack top (004011C5+5 = 004011CA)
004011C9 retn                   // pop  004011CA, jmp 004011CA
004011C9 sub_4011C0 endp ; sp-analysis failed
004011C9
004011CA ; ------------------------------------------------------------
004011CA push ebp
004011CB mov ebp, esp
004011CD mov eax, [ebp+8]
004011D0 imul eax, 2Ah
004011D3 mov esp, ebp
004011D5 pop ebp
004011D6 retn
```
  * IDA cannot disassemble the codes above because of a rogue 'retn'.
  * to resolve this problem, we can patch the first 3 instructions with NOP directly. then adjust function boundary.
    * to adjust function boundary, place cursor inside the function and press ALT-P.
## Misusing Structured Exception Handlers
* unhandled exception: message box that informs the user that "an unhandled exception has occured".
* to find SEH chain: fs segment register -> TEB -> TIB (Thread Information Block) -> pointer to SEH chain.
* SEH chain is a simple linked list of 8 bytes data structure:
  ```
    struct _EXCEPTION_REGISTRATION {
    DWORD prev;
    DWORD handler;
    };
  ```
  * the first record to be called is the last record to be added to the list.
  * to achieve covert flow control, we just need to figure out how to add our own handler to the top of the list.
  ![SEHchain](./Figure15_6.JPG)
  * how to construct a new SEH record on stack:
  ```
    push ExceptionHandler
    push fs:[0]
    mov fs:[0], esp
  ```
  * ExceptionHandler will be called whenever an exception occurs.
* Software DEP: software data execution prevention.
  * DEP will prevent the addition of 3rd party exception handler at runtime, that an author can add /SAFESEH:NO to the linker command line to disable this.
  * when execeptionhandler is called, the stack will be altered. So we need to figure out a way to keep balance of the stack.
  * how to restore SEH chain to original state:
  ```
    mov esp, [esp+8]
    mov eax, fs:[0]
    mov eax, [eax]
    mov eax, [eax]
    mov fs:[0], eax
    add esp, 8
  ```
* sample of SEH method:
```
    00401050 mov eax, (offset loc_40106B+1)
    00401055 add eax, 14h                                   // eax = loc_401080
    00401058 push eax                                       // ExceptionHandler = loc_401080
    00401059 push large dword ptr fs:0 ; dwMilliseconds
    00401060 mov large fs:0, esp
    00401067 xor ecx, ecx
    00401069 div ecx                                        // enter SEH chain
    0040106B
    0040106B loc_40106B: ; DATA XREF: sub_401050o
    0040106B call near ptr Sleep
    00401070 retn
    00401070 sub_401050 endp ; sp-analysis failed
    00401070
    00401070 ; ------------------------------------------------------------------
    00401071 align 10h
    00401080 dd 824648Bh, 0A164h, 8B0000h, 0A364008Bh, 0
    00401094 dd 6808C483h
    00401098 dd offset aMysteryCode ; "Mystery Code"
    0040109C dd 2DE8h, 4C48300h, 3 dup(0CCCCCCCCh)
```
  * use C to convert loc_401080 into code:
  ```
    00401080 mov esp, [esp+8]
    00401084 mov eax, large fs:0
    0040108A mov eax, [eax]
    0040108C mov eax, [eax]
    0040108E mov large fs:0, eax
    00401094 add esp, 8
    00401097 push offset aMysteryCode ; "Mystery Code"
    0040109C call printf
  ```

# Thwarting Stack-Frame Analysis
* advance disasenbler can analyze instructions of a function to deduce the construction of a stack frame, which can be used to recognize variables and parameters.
```
    00401543 sub_401543 proc near ; CODE XREF: sub_4012D0+3Cp
    00401543 ; sub_401328+9Bp
    00401543
    00401543 arg_F4 = dword ptr 0F8h
    00401543 arg_F8 = dword ptr 0FCh
    00401543
    00401543 000 sub esp, 8             // assuming esp = esp0
                                        // esp = esp - 8
    00401546 008 sub esp, 4             // esp = esp - 4 = esp0 - 0xC
    00401549 00C cmp esp, 1000h
    0040154F 00C jl short loc_401556
    00401551 00C add esp, 4             // esp = esp + 4 = esp0 - 0x8
    00401554 008 jmp short loc_40155C
    00401556 ; --------------------------------------------------------------
    00401556
    00401556 loc_401556: ; CODE XREF: sub_401543+Cj
    00401556 00C add esp, 104h
    0040155C
    0040155C loc_40155C: ; CODE XREF: sub_401543+11j
    0040155C -F8 mov [esp-0F8h+arg_F8], 1E61h
    00401564 -F8 lea eax, [esp-0F8h+arg_F8]
    00401568 -F8 mov [esp-0F8h+arg_F4], eax
    0040156B -F8 mov edx, [esp-0F8h+arg_F4]
    0040156E -F8 mov eax, [esp-0F8h+arg_F8]
    00401572 -F8 inc eax
    00401573 -F8 mov [edx], eax
    00401575 -F8 mov eax, [esp-0F8h+arg_F4]
    00401578 -F8 mov eax, [eax]
    0040157A -F8 add esp, 8
    0040157D -100 retn
    0040157D sub_401543 endp ; sp-analysis failed
```
  * from left, the first column contains segment name and memory address. the second colume is ESP based, which means the function is esp based instead of ebp based. stack pointer offset column can be enableed by IDA options.
  * stack pointer offset shows ESP value relative to where it was at beginning of function.
    * stack pointer offset = esp value of function beginning - current esp value = esp0 - current esp
  * 0xF8 = 248: IDA is telling this function takes 62 arguments.
  * for 'cmp esp, 1000h', the comparison is virutally guaranteed to always result in '>=' branch being executed.
  * the core of the code is that, disassembler thinks 'add esp, 104h' is valid and will adjust esp accordingly, but actually it will never be executed.
  * how to solve? - use ALT-K to adjust esp.