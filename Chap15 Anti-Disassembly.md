# Understanding Anti-Disassembly
* When implementing anti-disassembly, the malware author creates a sequence that tricks the disassembler into showing a list of instructions that differ from those will be executed.
* example of a same sequence of instructions:
  * linear disassembler:
  ```
    jmp short near ptr loc_2+1
    ; ---------------------------------------------------------------------------
    loc_2: 
    call near ptr 15FF2A71h 
    or [ecx], dl
    inc eax
    ; ---------------------------------------------------------------------------
    db 0
  ```
  * flow-oriented disassembler:
  ```
    jmp short loc_3
    ; ---------------------------------------------------------------------------
    db 0E8h
    ; ---------------------------------------------------------------------------
    loc_3: 
    push 2Ah
    call Sleep
  ```

# Defeating Disassembly Algorithms
* 2 types of disassembler algorithms: linear and flow-oriented.
## Linear Disassembly
* linear disassembly iterates over a block of code, disassembling one instruction at a time linearly without deviating.
* linear disassembly uses the size of instruction to determine which byte to disassembly next, without regard for flow-control instructions.
* sample code to disassembly:
  ```
    char buffer[BUF_SIZE];
    int position = 0;
    while (position < BUF_SIZE) {
        x86_insn_t insn;
        int size = x86_disasm(buf, BUF_SIZE, 0, position, &insn);       // populate buf with instructions it just disassembled and return the size of the instruction. Also increment position by size.
        
        if (size != 0) {
            char disassembly_line[1024];
            x86_format_insn(&insn, disassembly_line, 1024, intel_syntax);
            printf("%s\n", disassembly_line);
            position += size;
        } else 
        {
            /* invalid/unrecognized instruction */
            position++;
        }
    }
    x86_cleanup();
  ```
    * this algorithm will keep **blindly disassembling** until end.
    * if the .text section contains not only code, it will also disassemble thus cause errors.
* linear disassebly is easiest to defeat because it cannot distinguish between code and data.
## Flow-Oriented Disassembly
* most commercial disassemblers use flow-oriented disassembly method, such as IDA.
* flow-oriented disassembly method examines each instruction and builds a list of locations to disassemble.
* example:
  ```
    test eax, eax
    jz short loc_1A
    push Failed_string
    call printf
    jmp short loc_1D
    ; ---------------------------------------------------------------------------
    Failed_string: db 'Failed',0
    ; ---------------------------------------------------------------------------
    loc_1A: 
    xor eax, eax
    loc_1D:
    retn
  ```
    * when disassembler meet 'jz' instruction as a conditional instruction, it will disassemble 'push' instruction, and add loc_1A to **a list of locations to disassemble in future**.
    * when disassembler meet 'jmp' instruction, it will addd loc_1D to **a list of locations to disassemble in future**. 
    * because 'jmp' is unconditional, disassembler will not disassemble the disassemble instructions after 'jmp'. Instead, disassembler will start to check **the list of locations to disassemble in future** and start to disassemble the list.
* when conditional branches give flow-oriented disassembler a choice of 2 places to disassemble: true or false. Most flow-oriented disassembler will **process false branch first**.
* when flow-oriented disassembler meet 'call' instruction, it will mostly **disassemble the instructions after call firstly**.
* special 'call' example:
  ![specialcall](./Figure15_1.JPG)
  * the purpose of the 'call' is to create a pointer to 'hello' string. Then pop the pointer and put it into eax.
  * when IDA disassemble it, it will be wrong as below:
  ```
    E8 06 00 00 00  call near ptr loc_4011CA+1
    68 65 6C 6C 6F  push 6F6C6C65h
    loc_4011CA:
    00 58 C3        add [eax-3Dh], bl
  ```
  * if IDA is wrong, can use C or D keys:
    * C turns cursor location into code.
    * D turns cursor location into data.

# Anti-Disassembly Techniques
## Jump Instructions with the Same Target
* most common anti-disassembly technique is 2 back-to-back conditional jump instructions that both point to the same target.
* example:
  ```
    74 03 jz short near ptr loc_4011C4+1
    75 01 jnz short near ptr loc_4011C4+1
    loc_4011C4: ; CODE XREF: sub_4011C0
    ; sub_4011C0+2j
    E8 58 C3 90 90 call near ptr 90D0D521h
  ```
  * when disassembler encounters jz or jnz, it continues disassembling the false branch.
  * but the loc_4011C4+1 is 1 byte beyond E8 which is 58. but disassembler will disassemble E8 as call.
  * after D fixing, it should be like this:
  ```
    74 03 jz short near ptr loc_4011C5
    75 01 jnz short near ptr loc_4011C5
    ; -------------------------------------------------------------------
    E8 db 0E8h
    ; -------------------------------------------------------------------
    loc_4011C5: ; CODE XREF: sub_ 4011C0
    ; sub_4011C0+2j
    58 pop eax
    C3 retn
  ```
  * IDA show bytes: Options->General.
## A Jump Instruction with a Constant Condition
* another anti-disassembly technique: a single conditional jump where the condition will be always same.
