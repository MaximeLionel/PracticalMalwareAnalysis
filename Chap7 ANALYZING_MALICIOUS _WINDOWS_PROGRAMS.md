# Windows API
## Types and Hungarian Notation
* Common Windows API types: WORD, DWORD, Handles, Long Pointer, Call Back.
## Handles
* handles cannot be used in arithmetic operations, and do not always represent the object's address.
## File System Functions
* one of the common ways that malware interacts with the system is by creating or modifying files.
* Microsoft APIs:
  * CreateFile;
  * ReadFile and WriteFile;
  * CreateFileMapping and MapViewOfFile:
    * FileMapping allows a file to be loaded into memory and manipulated easily.
    * CreateFileMapping loads a file from disk into memory. MapViewOfFile returns a pointer to the base address of the mapping.
    * File mappings are commonly used to replicate functions of Windows Loader.
    * After obtaining pointer of file map in memory, malware can make all changes to the file and then execute.
## Special Files
* special files can be stealthier than regular ones because don't show up in directory.
* certain special files can provide greater access to system hardware and software.
* special files can be passed as strings to any of the file-manipulation functions.
### Shared Files
* shared file are special files with names starting with '\serverName\share' or '\\\\?\serverName\share'.
* access directories or files in a shared folder stored on internet.
* '\\\\?\' tells OS to disable parse strings.
### Files Accessible via Namespaces
* additional files are accessible via namespaces within OS.
* namespace is a fixed number of folders, each storing different types of objects.
* Lowest level namespace is NT namespace with prefix \\.
* win32 device namespace (\\\\.\\) is often used by malware to access physical devices directly, and read or write to them like a file.
  * malware may use \\\\.\\PhysicalDisk1 to directly access PhysicalDisk1 while ignoring file system.
  * \\Device\\PhysicalMemory can only be accessed from kernel space, which can be used to get information like BIOS and configuration.
### Alternate Data Streams
* alternate data streams (ADS) allows additional data to be added to the existing file within NTFS.
* the extra data will not show in a file directory but it only visible when access the stream.
* ADS data is named to the convention: normalFile.txt:Stream:$Data.

# The Windows Registry
* windows registry is used to store **OS and program configuration information**.
* malware often uses the registry for persistence or configuration data.
  * malware adds entries into registry to **run automatically** when system boots up.
  * there are many ways for malware to use it for persistence.
* important registry terms:
  * Root Key - registry is divided into 5 top-level sections (root keys). sometimes HKEY and hive are also used.
  * Subkey.
  * Key.
  * Value Entry - an ordered pair with a name and a value.
  * Value or data.
## Registry Root Keys
* 5 root keys:
  * HKEY_LOCAL_MACHINE (HKLM) - settings that are global to the local machine.
  * HKEY_CURRENT_USER (HKCU) - settings that are specific to current user.
  * HKEY_CLASSES_ROOT - information defining types.
  * HKEY_CURRENT_CONFIG - setting about current hardware configuration.
  * HKEY_USERS - settings for the default user, new user and current user.
* 2 most commonly used root key: **HKLM** and **HKCU**.
* Examples:
  * HKEY_USERS\SID - security identifier of the user currently logged in.
  * HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run - executables that are started automatically when a user logged in.
## Regedit
* regedit editor.
## Programs that Run Automatically
## Common Registry Functions
* malware often uses registry functions to modify the registry to run automatically when the system boots:
  * RegOpenKeyEx.
  * RegSetValueEx.
  * RegGetValue.
## Analyzing Registry Code in Practice
## Registry Scripting with .reg Files
* Files with .reg extension contain human-readable registry data. Double-click can automatically modify the registry key value.
* .reg file:
  ```
    Windows Registry Editor Version 5.00
    [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run]
    "MaliciousValue"="C:\Windows\evil.exe"
  ```
  * add the value name 'MaliciousValue' which will automatically run "C:\Windows\evil.exe".

# Networking APIs
## Berkeley Compatible Sockets
* malware most commonly uses Berkeley compatible sockets.
* Berkeley compatible sockets' network functionality is implemented in **Winsock libraries**, primarily in **ws2_32.dll**.
* Most common APIs: 
  * socket - create a socket.
  * bind - attaches a socket to a particular **port**.
  * listen - indicates that a socket will be listening for incoming connections.
  * accept.
  * connect.
  * recv.
  * send.
* **WSAStartup** function must be called before any other networking functions in order to **allocate resources** for the networking libraries.
  * when debug, we can set a breakpoint on WSAStartup to analyze the following network operatoins after.
## the Server and Client Sides of Networking
* there are always 2 sides of a networking program: **server side** and **client server**.
  * client function order: socket - connect- send - recv.
  * server fuction order: socket - bind - listen - accept - send - recv.
## the WinINet API
* higher-level API: WinINet API stored in Wininet.dll.
* WinINet API implement HTTP, FTP protocols at application layer.
* WinINet important APIs:
  * InternetOpen.
  * InternetOpenUrl.
  * InternetReadFile.
* malware can use WinINet API to connect to a remote server and get further instructions for execution.

# Following Running Malware
* many ways that malware can transfer execution to other code.
## DLLs
### How malware use Dlls
* to store malicious code.
  * malware sometimes uses Dlls to load itself into another process.
* by using Windows Dlls.
* by using third-party Dlls.
  * when see malware that imports functions from a third-party dll, means the malware is interacting with that program to achieve its goal. such as using Mozilla Firefox DLL to connect to server.
### Basic DLL structure
* DllMain is called when a process loads or unloads the library, creates a new thread or finish an existing thread.
## Processes
* newer malware commonly execute its code as part of another process.
### Creating a new process
* CreateProcess function:
  * malware can call to **create a process to execute the malicious code**, that is to bypass host-based firewalls and other security mechanisms.
  * malware can also create an instance of Internet Explorer to access malicious content.
* malware commonly use CreateProcess to create a simple remote shell:
  * one parameter - STARTUPINFO struct: includes a handle to standard input, standard output and standard error streams for a process.
  * malicious program could set STARTUPINFOR value to a socket. So that when the program writes to standard output, it actually writes to a socket.
  * So attacker executes a shell remotely without execute functions other than CreateProcess.
  * sample code:
  ```
    004010DA mov eax, dword ptr [esp+58h+SocketHandle]
    004010DE lea edx, [esp+58h+StartupInfo]
    004010E2 push ecx ; lpProcessInformation
    004010E3 push edx ; lpStartupInfo
    004010E4 mov [esp+60h+StartupInfo.hStdError], eax
    004010E8 mov [esp+60h+StartupInfo.hStdOutput], eax
    004010EC mov [esp+60h+StartupInfo.hStdInput], eax
    004010F0 mov eax, dword_403098
    004010F5 push 0 ; lpCurrentDirectory
    004010F7 push 0 ; lpEnvironment
    004010F9 push 0 ; dwCreationFlags
    004010FB mov dword ptr [esp+6Ch+CommandLine], eax
    004010FF push 1 ; bInheritHandles
    00401101 push 0 ; lpThreadAttributes
    00401103 lea eax, [esp+74h+CommandLine]
    00401107 push 0 ; lpProcessAttributes
    00401109push eax ; lpCommandLine
    0040110A push 0 ; lpApplicationName
    0040110C mov [esp+80h+StartupInfo.dwFlags], 101h
    00401114call ds:CreateProcessA
  ```
  * to find the remote host, need to find where the socket is initialized.
* malware often creates a new process by storing one program inside another in the resource section.
## Threads
* threads within a process all share the same memory space, but each has its own processor registers and stack.
### Thread Context
* when one thread is running, it has complete control of the CPU, or CPU core, and other threads cannot affect the state of the CPU or core.
* before CPU switches between threads, all CPU values are saved in a structure called **thread context**.
### Creating a Thread
* when analyzing code that calls CreateThread, need to analyze the **start** function (the parameter CreateThread specifies).
* malware use CreateThread in multiple ways:
  * use CreateThread to **load a malicious library into a process** with the address of LoadLibrary specified as a parameter.
  * create 2 threads for input and output: 
    * input - listen on a socket or pipe and send data to standard input of a process.
    * output - read from standard output and send data to a socket or pipe.
    ```
        004016EE lea eax, [ebp+ThreadId]
        004016F4 push eax ; lpThreadId
        004016F5 push 0 ; dwCreationFlags
        004016F7 push 0 ; lpParameter
        004016F9 push offset ThreadFunction1 ; lpStartAddress  ; input: ReadFile, send
        004016FE push 0 ; dwStackSize
        00401700 lea ecx, [ebp+ThreadAttributes]
        00401706 push ecx ; lpThreadAttributes
        00401707 call ds:CreateThread
        0040170D mov [ebp+var_59C], eax
        00401713 lea edx, [ebp+ThreadId]
        00401719 push edx ; lpThreadId
        0040171A push 0 ; dwCreationFlags
        0040171C push 0 ; lpParameter
        0040171E push offset ThreadFunction2 ; lpStartAddress  ; output: recv, WriteFile
        00401723 push 0 ; dwStackSize
        00401725 lea eax, [ebp+ThreadAttributes]
        0040172B push eax ; lpThreadAttributes
        0040172C call ds:CreateThread
    ```
* fibers are like threads, which are managed by threads. Fibers share a single thread context.
## Interprocess Coordination with Mutexes
* mutexes are global objects that coordinate multiple processes and threads. mainly used to control access to shared resources.
* only one thread can own a mutex at a time.
* thread gains access to the mutex with a call to **WaitForSingleObject**. When a thread is finished, it uses **ReleaseMutex** to release the mutex. A mutex can be created with **CreateMutex**. One process can get a handle to another process's mutex by using **OpenMutex**.
  ```
    00401000 push offset Name ; "HGL345"
    00401005 push 0 ; bInheritHandle
    00401007 push 1F0001h ; dwDesiredAccess
    0040100C call ds:__imp__OpenMutexW@12 ; OpenMutexW(x,x,x)
    00401012 test eax, eax             // check if there's already an "HGL345" mutex.
    00401014 jz short loc_40101E
    00401016 push 0 ; int
    00401018 call ds:__imp__exit
    0040101E push offset Name ; "HGL345"
    00401023 push 0 ; bInitialOwner
    00401025 push 0 ; lpMutexAttributes
    00401027 call ds:__imp__CreateMutexW@12 ; CreateMutexW(x,x,x)
  ```
## Services
* another way to execute malicious code is by installing it as a service. code will be scheduled and run by service manager without user input.
* services are normally run as **SYSTEM** or another privileged account.
* services can be set to run automatically when boots up and may not show up in Task Manager as a process.
* **Autoruns** tool can be used to gather more information of services. command 'net start' to list running services.
* important service functions:
  * OpenSCManager - returns a handle to the service control manager.
  * CreateService - start a new service to service control manager.
  * StartService - start a service and is used only if the service is set to be start manually.
* service types for malicious code:
  * service type malware use is WIN32_SHARE_PROCESS, which stores code for a service in a DLL. 
    * In Task Manager, svchost.exe instances are running WIN32_SHARE_PROCESS.
  * WIN32_OWN_PROCESS is also used because it stores code into a exe file and runs as an independent process.
  * KERNEL_DRIVER is used for loading code into the kernel.
* service information on registry: HKLM\SYSTEM\CurrentControlSet\Services
![registryservices](./Figure7_2.JPG)
  * 1 - file path.
  * 2 - 0x02 = AUTO_START.
  * 3 - 0x10 = WIN32_OWN_PROCESS.
* SC program is a command-line tool that to investigate and manipulate services.
  ```
    C:\Users\User1>sc qc "VMware NAT Service"
    [SC] QueryServiceConfig SUCCESS
    SERVICE_NAME: VMware NAT Service
    TYPE : 10 WIN32_OWN_PROCESS
    START_TYPE : 2 AUTO_START
    ERROR_CONTROL : 1 NORMAL
    BINARY_PATH_NAME : C:\Windows\system32\vmnat.exe
    LOAD_ORDER_GROUP :
    TAG : 0
    DISPLAY_NAME : VMware NAT Service
    DEPENDENCIES : VMnetuserif
    SERVICE_START_NAME : LocalSystem
  ```
## the Component Object Model (COM)
* COM: a standard interface that make it possible for different software components to call each other's code without knowing details.
* COM is implemented as a client/server framework.
  * clients are the programs that make use of COM object.
  * servers are the COM objects themselves.
* each thread that uses COM must call **OleInitialize** or **CoInitializeEx** before calling other COM library functions. malware analyst can search the 2 functions to determine if malware use services.
### CLSIDs, IIDs, and the Use of COM Objects
* COM objects are access via **global unique identifiers (GUIDs)** known as **class identifiers (CLSIDs)** and **interface identifiers (IIDs)**.
  * interfaces are identified by IIDs.
  * classes are identified by CLSIDs.
* **CoCreateInstance** is used to get access to COM functionality.
* **Navigate** allows a program to launch Internet Explorer and access a web address.
* Navigate is part of IWebBrowser2 interface. In most cases, IWebBrowser2 interface is implemented by Internet Explorer.
```
    00401024 lea eax, [esp+18h+PointerToComObject]
    00401028 push eax ; ppv
    00401029 push offset IID_IWebBrowser2 ; riid
    0040102E push 4 ; dwClsContext
    00401030 push 0 ; pUnkOuter
    00401032 push offset stru_40211C ; rclsid
    00401037 call CoCreateInstance
```
* when a program calls CoCreateInstance, registry will tell which file contains the requested COM code:
  * HKLM\SOFTWARE\Classes\CLSID\
  * HKCU\SOFTWARE\Classes\CLSID\
* Once a structure is returned from CoCreateInstance, the COM client will call a function whose location is stored at an offset in the structure
```
    0040105E push ecx
    0040105F push ecx
    00401060 push ecx
    00401061 mov esi, eax
    00401063 mov eax, [esp+24h+PointerToComObject]
    00401067 mov edx, [eax]
    00401069 mov edx, [edx+2Ch]
    0040106C push ecx
    0040106D push esi
    0040106E push eax
    0040106F call edx
```
### COM Server Malware
* common COM server functionality for malware is through Browser Helper Object (BHO). malware use it to run code in Internet Explorer process.
## Exceptions: When Things Go Wrong
* Structured Exception Handling (SEH).
* in 32bit systems, SEH information is stored on stack.
* storing exception-handler information in fs:0
  ```
    01006170 push offset loc_10061C0   // an exception-handler frame is put onto the stack.
    01006175 mov eax, large fs:0        // fs:0 points to an address on the stack that stores exception information.
    0100617B push eax
    0100617C mov large fs:0, esp
  ```
* malware can overwrite the pointer to exception-handling information stored on the stack.

# Kernel vs User Mode
* the presence of SYSENTER, SYSCALL, or INT 0x2e instruction indicates that a call is being made into the kernel.
* kernel-mode code has fewer security checks.
* malware running in kernel is more powerful than malware running in user-mode.

# the Native API
* Native API is low-level interface for interacting with Windows that is rarely used by nonmalicious program, but is commonly used by malware.
* calling Native API can bypass normal Windows API.
![kernelusermode](./figure7_3.JPG)
* best reference of Native API: 
  * Windows NT/2000 Native API Reference by Gary Nebbett (Sams, 2000).
  * http://undocumented.ntinternals.net/.
* ntdll.dll uses Native APIs.
* there's a lot of functionality that is not exposed in regular Windows API, but can be accomplished by calling Native APIs.
* if process calls Native API, it may be able to evade to a poor designed security product. Well designed security program will monitor calls at all levels, including kernel.
  * malware may use NtReadFile and NtWriteFile instead of ReadFile and WriteFile.
* Native APIs to get system information: NtQuerySystemInformation, NtQueryInformationProcess, NtQueryInformationThread, NtQueryInformationFile, and NtQueryInformationKey.
* NtContinue: return from an exception and transfer execution back to the main thread of a program.